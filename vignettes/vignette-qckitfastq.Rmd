---
title: "Introduction to qckitfastq"
author: "Wenyue Xing and August Guang"
package: qckitfastq
vignette: >
  %\VignetteIndexEntry{Quality control analysis and visualization using qckitfastq }
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: qckitfastq.bib
---

```{r, setup, include=FALSE}
library(knitr)
library(kableExtra)
```

# Introduction

`qckitfastq` is part of the `qckit` suite of packages, the description of which can be found at
[http://compbiocore.github.io/qckit](http://compbiocore.github.io/qckit). The purpose of this particular
package is to run quality control on FASTQ files from genome sequencing.

## Why use qckitfastq?

Indeed there are many other quality control packages for FASTQ files existing already, including ShortReads [@shortread] and seqTools [@seqtools] for R and the popular FASTQC [@Andrews2010] Java-based program. qckitfastq offers a few advantages compared to these 3 programs for users who need such features:

  1. access to raw sequence and quality data
  2. quality control analyses of the entire FASTQ file
  3. fast file processing
  
To break it down further, seqTools and ShortReads do not offer as comprehensive set of quality control metrics as qckitfastq and FASTQC. seqTools further provides limited access to raw data and intermediate analysis results. ShortRead provides users with access to the raw sequencing data and intermedite analysis results, but is inefficient on datasets exceeding 10 million reads. FASTQC meanwhile truncates any reads longer than 75bp as well as estimates overall quality only based on the first 100,000 reads of any FASTQ file. `qckitfastq` does not contain any of these limitations.

```{r, comparison_table}
qckitfastq <- c("yes","yes+","yes")
seqTools <- c("yes","yes","yes")
ShortRead <- c("no","no","yes")
FASTQC <- c("yes*","yes*","yes*")
metrics <- data.frame(qckitfastq,seqTools,ShortRead,FASTQC)
rownames(metrics) <- c("Per Base Sequence Quality", "Nucleotide Sequence Content", "blah2")
kable(metrics)
```

## Planned improvements

As is described on the [qckit project page](http://compbiocore.github.io/qckit), the long-term goal of the qckit suite is to not only provide comprehensive quality control metrics for common genomics sequencing workflows, but to 1) also provide quality control visualizations for multiple samples through updated modules in multiQC [@Ewels2016], and 2) provide a public quality control database which allows benchmarking of QC metrics for an experiment against other similar experiments. Users of `qckitfastq` will have the option to enter SRA metadata and create visualizations from our database as well as submit their qc results (if submitting an SRA archive) to our database once these features have been implemented.

# Running qckitfastq

`qckitfastq` provides the following metrics:

  * Per base sequence quality
  * Nucleotide sequence content
  * GC content
  * Kmer count
  * Adapter content
  * (fill out as we go thru man pages)

We provide a single command that the user can run to get a report of all of the included metrics, `run_all` but also provide the ability to run each metric separately and examine the results as a data frame.

# Individual metrics

Our example in this vignette has 25,000 reads, each 100bp long. The majority of metrics are run on the path to the FASTQ file. Some functions for quality control in this package are simply wrappers around `seqTools` due to the fact that their functions are fast. We provide these wrappers for the sake of completeness in quality control metrics. These wrappers require processing the FASTQ data through the `seqTools::fastqq` command first:
```{r, loading_file}
library(qckitfastq)
infile <- system.file("extdata", "10^5_reads_test.fq.gz", package = "qckitfastq")
fseq <- seqTools::fastqq(infile)
```

The rest of this vignette will be divided into functions that make use of `seqTools::fastqq` and those that use more customized C++ code.

## C++ based metrics

### Per base quality score statistics

The *per_base_quality* function calculates quality score per base summary statistics including mean, median and quantiles across sequences. We can use the result to create a quality score distribution per position plot to present the overall dispersion and concentration of quality score per position of the FASTQ file.

```{r}
bs <- per_base_quality(infile)
knitr::kable(head(bs))
plot_per_base_quality(bs)
```

## GC content


Function *GC_content* utilizes the result from the C++_calling function *GC_per_read* and produce the data frame that is more suitable for the plotting purpose as well as for saving to data file for later access. The result is the GC content percentage per read and will be saved in resulting table. 

```{r}

gc_df <- GC_content(infile)

knitr::kable(head(gc_df))


```


The *plot_GC_content_plot* function takes the input from previous function and generates plot of distribution of GC nucleotide sequence content percentage. The graph would be an indication of good data quality when the  GC percentage concentrated around 30 to 50 and the results do not differ among different bases. 


```{r}

plot_GC_content(nc,gc_df)


```

### Benchmarking

To demonstrate the utility of our functions on large datasets...
(need to benchmark against ShortRead)

```{r}
library(seqTools)
library(ShortRead)
library(rbenchmark)
sampler <- FastqSampler('E-MTAB-1147/fastq/ERR127302_1.fastq.gz', 20000)
```

## seqTools::fastqq based metrics

### Basic metrics

We provide some basic metrics such as the number of reads and number of positions under the function *dimensions*. Here the sample file has 25,000 reads and 100 positions. This allows us to examine whether the sequence lengths are uniform throughout the entire file. The results from this section are useful for certain analyses where dimensionality of data is important for calculation, such as *overrep_kmer*,. 

```{r}
nc <- dimensions(fseq,"positions")
nc

nr <- dimensions(fseq,"reads")
nr
```

*plot_read_length* generates a distribution plot of the length of all reads. The generated plot would show the sequence length of all the sequences throughout the file. The plot is considered an indication of good data quality is all sequences have the same sequence length with no deviations. The following plot shows that all reads in the file have sequence length of 100.

```{r}
plot_read_length(fseq)
```

*plot_per_base_quality* function generates a boxplot of the quality score distribution per base. In this section, we would like to examine whether certain portion of the sequences have generally low quality score. If a subset of seqences have quality score generally small(<30) [what was Winnie going for here?]

### Nucleotide sequence content

*sequence_content* calculates the total number of each nucleotide sequence content per sequence throughout the file. *plot_sequence_conent* uses the *sequence_content* function and plots the percentage of all nucleotide sequence content per position. The plot would be considered an indication of good data quality when the percentage of each nucleotide sequence content is not significantly larger than other nucleotide sequence contents. In this section, we examine whether each nucleotide sequence content are distributed evenly at all bases. The data is problematic if any sequence bias greatly from other sequence content in any subset of sequences.

```{r}
scA <- sequence_content(fseq, content = "A")
head(scA)
plot_sequence_content(fseq,nr,nc)
```

## Per read sequence quality score

*plot_perseq_quality* function extracts the mean quality score per read and generate a histogram of this statistics.It takes the input of the path to the gzipped FASTQ files. It also enables plot saving if set *writefile* to TRUE and input a *prefix* value to customize name of saved file. The histogram would be considered an indication of good data quality when the majority of reads have high quality score(around 30). If a significant portion of read are with low quality score, say less than 20, then data is problematic. 


```{r}

plot_perseq_quality(infile,writefile=FALSE)

```

## Kmers count per base

*kmer_count* function produces the per position kmer count with given path to the FASTQ file and the kmer length specified. 

```{r}

km <- Kmer_count(infile,k=6)
knitr::kable(km[1:20,1:10])

```

## Overrepresented kmers
The function generates list of overrepresented kmers with its maximum obs/exp ratio and the position of maximum obs/exp ratio. 


```{r}
overkm <-overrep_kmer(infile,7,nc,nr)
knitr::kable(head(overkm,n=10))
```

## Overrepresented sequences

Taking in the output generated from *cal_over_rep_seq*, function *overrepresented_sequence* produce the overrepresented sequence table by selecting the unique sequences that have counts larger than 0.1% of the total reads of the data file. The results would be displayed as table with decreasing order of counts.


```{r}
overrep_sequence(infile,nr,prefix="test")
knitr::kable(head(overrep_sequence,n = 5))
```

Function *overrepresented_plot* would take the overrepresented sequence table as input and present a density plot of the counts and mark the top 5 overrepresented sequence in red. 


```{r}
plot_overrep_seq(overrep_sequence,FALSE)
```